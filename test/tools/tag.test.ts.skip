/**
 * Tag Tool Tests - Flat Architecture
 *
 * Tests for the new flat tag tool implementation
 */

import { describe, test, expect, beforeEach, jest } from '@jest/globals';
import { tagImage, createTagTool } from '../../src/tools/tag';
import * as sessionManagerModule from '../../src/lib/session';
import * as dockerClientModule from '../../src/lib/docker';
import { createMockLogger } from '../utils/mock-factories';
import type { Logger } from 'pino';

// Mock the lib modules
jest.mock('../../src/lib/session');
jest.mock('../../src/lib/docker');

const mockSessionManager = sessionManagerModule.sessionManager as jest.Mocked<typeof sessionManagerModule.sessionManager>;
const mockDockerClient = dockerClientModule.dockerClient as jest.Mocked<typeof dockerClientModule.dockerClient>;

describe('Tag Tool', () => {
  let logger: Logger;
  
  beforeEach(() => {
    logger = createMockLogger();
    jest.clearAllMocks();
  });
  
  describe('tagImage function', () => {
    test('should successfully tag image', async () => {
      // Arrange
      const config = {
        sessionId: 'test-session-123',
        tag: 'myapp:1.0.0',
      };
      
      const mockSession = {
        id: 'test-session-123',
        workflow_state: {
          build_result: {
            imageId: 'sha256:abc123',
            tags: [],
          },
        },
      };
      
      mockSessionManager.get.mockResolvedValue({
        success: true,
        data: mockSession,
      });
      
      mockDockerClient.tagImage.mockResolvedValue({
        success: true,
        data: { tagged: true },
      });
      
      mockSessionManager.update.mockResolvedValue({
        success: true,
        data: mockSession,
      });
      
      // Act
      const result = await tagImage(config, logger);
      
      // Assert
      expect(result.success).toBe(true);
      expect(result.data).toEqual({
        success: true,
        sessionId: 'test-session-123',
        tags: ['myapp:1.0.0'],
        imageId: 'sha256:abc123',
      });
      
      expect(mockSessionManager.get).toHaveBeenCalledWith('test-session-123');
      expect(mockDockerClient.tagImage).toHaveBeenCalledWith('sha256:abc123', 'myapp:1.0.0', logger);
      expect(mockSessionManager.update).toHaveBeenCalledWith('test-session-123', {
        workflow_state: {
          build_result: {
            imageId: 'sha256:abc123',
            tags: ['myapp:1.0.0'],
          },
        },
      });
    });
    
    test('should fail when session not found', async () => {
      // Arrange
      const config = {
        sessionId: 'non-existent-session',
        tag: 'myapp:1.0.0',
      };
      
      mockSessionManager.get.mockResolvedValue({
        success: false,
        error: 'Session not found',
      });
      
      // Act
      const result = await tagImage(config, logger);
      
      // Assert
      expect(result.success).toBe(false);
      expect(result.error).toBe('Session not found');
      
      expect(mockDockerClient.tagImage).not.toHaveBeenCalled();
      expect(mockSessionManager.update).not.toHaveBeenCalled();
    });
    
    test('should fail when no built image in session', async () => {
      // Arrange
      const config = {
        sessionId: 'test-session-123',
        tag: 'myapp:1.0.0',
      };
      
      const mockSession = {
        id: 'test-session-123',
        workflow_state: {
          // No build_result
        },
      };
      
      mockSessionManager.get.mockResolvedValue({
        success: true,
        data: mockSession,
      });
      
      // Act
      const result = await tagImage(config, logger);
      
      // Assert
      expect(result.success).toBe(false);
      expect(result.error).toBe('No built image found in session - run build_image first');
      
      expect(mockDockerClient.tagImage).not.toHaveBeenCalled();
    });
    
    test('should fail when docker tag operation fails', async () => {
      // Arrange
      const config = {
        sessionId: 'test-session-123',
        tag: 'myapp:1.0.0',
      };
      
      const mockSession = {
        id: 'test-session-123',
        workflow_state: {
          build_result: {
            imageId: 'sha256:abc123',
          },
        },
      };
      
      mockSessionManager.get.mockResolvedValue({
        success: true,
        data: mockSession,
      });
      
      mockDockerClient.tagImage.mockResolvedValue({
        success: false,
        error: 'Docker daemon not running',
      });
      
      // Act
      const result = await tagImage(config, logger);
      
      // Assert
      expect(result.success).toBe(false);
      expect(result.error).toBe('Failed to tag image: Docker daemon not running');
      
      expect(mockSessionManager.update).not.toHaveBeenCalled();
    });
    
    test('should handle exceptions gracefully', async () => {
      // Arrange
      const config = {
        sessionId: 'test-session-123',
        tag: 'myapp:1.0.0',
      };
      
      mockSessionManager.get.mockRejectedValue(new Error('Database connection failed'));
      
      // Act
      const result = await tagImage(config, logger);
      
      // Assert
      expect(result.success).toBe(false);
      expect(result.error).toBe('Database connection failed');
    });
  });
  
  describe('createTagTool factory', () => {
    test('should create tool with correct interface', () => {
      // Act
      const tool = createTagTool(logger);
      
      // Assert
      expect(tool.name).toBe('tag');
      expect(typeof tool.execute).toBe('function');
    });
    
    test('should execute tool correctly', async () => {
      // Arrange
      const tool = createTagTool(logger);
      const config = {
        sessionId: 'test-session-123',
        tag: 'myapp:1.0.0',
      };
      
      const mockSession = {
        id: 'test-session-123',
        workflow_state: {
          build_result: {
            imageId: 'sha256:abc123',
          },
        },
      };
      
      mockSessionManager.get.mockResolvedValue({
        success: true,
        data: mockSession,
      });
      
      mockDockerClient.tagImage.mockResolvedValue({
        success: true,
        data: { tagged: true },
      });
      
      mockSessionManager.update.mockResolvedValue({
        success: true,
        data: mockSession,
      });
      
      // Act
      const result = await tool.execute(config);
      
      // Assert
      expect(result.success).toBe(true);
      expect(result.data?.tags).toEqual(['myapp:1.0.0']);
    });
  });
});